<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="/assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Noetic Nought (programming)</title><link>https://punchagan.muse-amuse.in/</link><description></description><atom:link href="https://punchagan.muse-amuse.in/tags/programming.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 14 Jun 2016 17:56:04 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Assist time</title><link>https://punchagan.muse-amuse.in/posts/assist-time.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
I sometimes hang out on &lt;a href="http://webchat.freenode.net/?channels=%2523org-mode"&gt;#org-mode&lt;/a&gt; or &lt;a href="http://webchat.freenode.net/?channels=%2523nikola"&gt;#nikola&lt;/a&gt; and answer questions. I usually am
not able to answer off the top of my head and I look up docs or dig through the
code.  Sometimes, we find ready-made documented answers, but other times we end
up contributing some documentation, filing an issue, submitting a patch or
hacking up something for that super-special use-case.
&lt;/p&gt;

&lt;p&gt;
Until now, I looked at this time as IRC time, which loosely translates to
distraction time.  But, I'm usually learning about the tools I use a little bit
more. Even when I'm not, I'm helping someone do something they want to do.
Sometimes empowering them to fix future problems on their own.  And indirectly
making the user community a wee-bit happier, and possibly the software a tiny
bit better.
&lt;/p&gt;

&lt;p&gt;
This isn't limited just to helping someone on IRC.  Helping out a co-worker do
something that they are new to, or just adding a comment or editing a
Stack-overflow answer may end up in the "distraction time" bin, just because
you weren't doing something on your TODO list.  It needn't be.
&lt;/p&gt;

&lt;p&gt;
Taking cue from &lt;a href="https://en.wikipedia.org/wiki/Assist_(football)"&gt;scorers in Football&lt;/a&gt;, I decided to call this time &lt;b&gt;assist time&lt;/b&gt;
and to try to start seeing this time as (semi-)productive. Naming helps.
&lt;/p&gt;</description><category>blab</category><category>blag</category><category>productivity</category><category>programming</category><category>time</category><guid>https://punchagan.muse-amuse.in/posts/assist-time.html</guid><pubDate>Tue, 14 Jun 2016 14:28:56 GMT</pubDate></item><item><title>Reading-time based scheduling</title><link>https://punchagan.muse-amuse.in/posts/reading-time-based-scheduling.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
I had posted a link to an poem written on Medium on a Slack channel that I use
with friends.  A friend said that she liked the fact that the Slack article
preview had the reading time from Medium in it.  She could decide whether or
not she wanted to read the poem or any other article at that moment.
&lt;/p&gt;

&lt;p&gt;
This gave me the idea for a reading time extension for my &lt;a href="https://www.chromium.org/getting-involved/download-chromium"&gt;browser&lt;/a&gt;, or my &lt;a href="https://github.com/skeeto/elfeed"&gt;feed
reader&lt;/a&gt; or my &lt;a href="https://pinboard.in"&gt;bookmarks&lt;/a&gt; – my reading list.  The first version should be able to
compute or extract the reading time for an article or a tab in my browser, and
index them.  I want to be able to specify the amount of time I will be able to
spend reading, and be presented with something from my reading list.  I think
this would help with scheduling the reading of longer articles, and also to
actually help me get through my reading list.
&lt;/p&gt;

&lt;p&gt;
Reading time estimates that use heuristics based on word-count may not really
work, and may do &lt;a href="https://medium.com/@fchimero/this-should-only-take-a-minute-or-four-probably-e38bb7bf2adf#.mvkd09m6m"&gt;more harm than good&lt;/a&gt;.  But, it may still be worth a try to see
if it helps my reading habits in any way.  A quick search pointed me to &lt;a href="https://chrome.google.com/webstore/detail/readism-article-reading-t/bmiolhceebkeljaikojgcoeefblcihje"&gt;this
extension&lt;/a&gt;, that can give the reading time for any page but doesn't really do
what I want.
&lt;/p&gt;</description><category>blag</category><category>hack</category><category>idea</category><category>programming</category><category>reading</category><guid>https://punchagan.muse-amuse.in/posts/reading-time-based-scheduling.html</guid><pubDate>Mon, 06 Jun 2016 07:43:12 GMT</pubDate></item><item><title>Stepping AFK</title><link>https://punchagan.muse-amuse.in/posts/stepping-afk.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
In the past few weeks, I noticed three instances where I was forced to take a
break exactly when I was ready to jump in and write some code to fix a bug or
add a small feature.  I had to step out of the house and take a walk to meet
someone, etc.
&lt;/p&gt;

&lt;p&gt;
I ended up getting ideas during the walks, which significantly changed and
simplified how I would've implemented things, if not for those breaks.  Even if
I did end up zeroing down to those solutions, I am pretty sure it would've
taken a couple of not-so-good attempts and much longer than it did.
&lt;/p&gt;

&lt;p&gt;
Context switches are usually considered to be &lt;a href="http://heeris.id.au/2013/this-is-why-you-shouldnt-interrupt-a-programmer/"&gt;expensive for programmers&lt;/a&gt;, but
taking a break at the exact time when I had all the required context loaded
into my head seemed to help. It was also probably helpful that I was taking a
walk, and there wasn't really any other inputs or outputs competing for the
space in my head.
&lt;/p&gt;

&lt;p&gt;
This got me thinking about doing this more deliberately – I'd love to hear
about any experiences or any experiments any of you have done with this.  Also,
I'm reminded of Rich Hickey's &lt;a href="https://www.youtube.com/watch?v=f84n5oFoZBc"&gt;Hammock Driven Development&lt;/a&gt; talk and I wonder if
this is a smaller/different version of it, and makes me want to try out the
things he suggests more deliberately.  If any of you has thoughts and
suggestions, I'd love to hear from you!
&lt;/p&gt;</description><category>blab</category><category>blag</category><category>programming</category><category>thought</category><guid>https://punchagan.muse-amuse.in/posts/stepping-afk.html</guid><pubDate>Fri, 03 Jun 2016 18:21:30 GMT</pubDate></item><item><title>Thinking about Data Ethics</title><link>https://punchagan.muse-amuse.in/posts/thinking-about-data-ethics.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
Earlier this month, a researcher made a dataset containing the profiles of about
70,000 users public. He didn't really see a problem in doing this because he
felt he was only presenting &lt;a href="https://twitter.com/KirkegaardEmil/status/730449904909324289"&gt;already publicly available&lt;/a&gt; data in a more usable
form. was only presenting it in a more usable form.
&lt;/p&gt;

&lt;p&gt;
Yesterday, I came across this quote in the very first chapter of &lt;a href="https://twitter.com/allendowney"&gt;Allen Downey&lt;/a&gt;'s
book &lt;a href="http://greenteapress.com/thinkstats2/index.html"&gt;Think Stats&lt;/a&gt; which I liked a lot, and reminded me of this incident.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://c2.staticflickr.com/8/7193/26969166130_58e4865f47_b.jpg" alt="26969166130_58e4865f47_b.jpg"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
I hadn't looked at the OKCupid data release and the discussion around it much,
but I went back and read &lt;a href="https://points.datasociety.net/okcupid-data-release-fiasco-ba0388348cd#.u8xxlkqsv"&gt;this article&lt;/a&gt; by a social media researcher who thinks a
lot about these things. 
&lt;/p&gt;

&lt;p&gt;
She puts forth a lot of interesting ideas to think about ethics. Some things
that stood out to me are:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Ask yourself how the person whose data you are using feels about the data.
&lt;/li&gt;
&lt;li&gt;Taking a 'what if' impact approach to thinking about data and ethics.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Also, you needn't really call yourself a researcher to be actually doing
experiments with (or &lt;a href="http://www.npr.org/2016/05/17/478266839/this-is-your-brain-on-uber"&gt;analyzing&lt;/a&gt;) "big-data" and discovering and putting out facts
that have an impact – however big or small. You should really go read the
article, whether or not you are a researcher using data.
&lt;/p&gt;

&lt;p&gt;
Incidentally, there is a meet-up on &lt;a href="http://www.meetup.com/DataKind-Bangalore/events/231310093/"&gt;Data Ethics&lt;/a&gt; this weekend in Bangalore. I'm
excited to learn and think more about this, and talk to others who care.
&lt;/p&gt;</description><category>blab</category><category>blag</category><category>data</category><category>ethics</category><category>programming</category><guid>https://punchagan.muse-amuse.in/posts/thinking-about-data-ethics.html</guid><pubDate>Wed, 25 May 2016 15:36:56 GMT</pubDate></item><item><title>Level-up Tools</title><link>https://punchagan.muse-amuse.in/posts/level-up-tools.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
Thanks to a &lt;a href="https://twitter.com/baali_"&gt;friend&lt;/a&gt; I got an upgrade to our still-being-setup kitchen.  I now
have a non-stick pan along with a few more new additions.  I would previously
use a bowl that people usually use to boil &lt;a href="http://img6a.flixcart.com/image/pot-pan/t/s/8/aluminium-polish-top-jk-vallabhdas-400x400-imae7w9y9ehukjhx.jpeg"&gt;milk&lt;/a&gt; etc. for making whatever I did.
The non-stick pan feels so great!  It has made it a lot simpler to make some of
the things I used to, because its non-stick. And it has vastly expanded the
possibilities of things I can make, by virtue of being flat and wide based.
The pan is such a great addition to my kitchen paraphernalia, and it adds a new
dimension to the kind of things I can make.  I'm not here to write a user
review for it, though.
&lt;/p&gt;

&lt;p&gt;
What are such tools in other things that you do, that drastically changed the
way you did something, or added a new dimension to the kinds of things you
could do, tools that make you feel like you have a new super-power?  Learning
to write Python (after starting off with C) seemed to give me so much power
allowing me to focus on the problem, rather than fussing over the low level
details. Sasha mentions in &lt;a href="http://sasha.wtf/anki-post-1/"&gt;this post&lt;/a&gt; how using a Spaced Repetition System like
&lt;a href="https://ankiweb.net/"&gt;Anki&lt;/a&gt; drastically improved her efficiency because she could focus on thinking
about higher level things rather than trying to recall or search for what
method or function to use to do something.
&lt;/p&gt;

&lt;p&gt;
What are some such level-up tools for you? Is there a systematic approach to
discovering tools?
&lt;/p&gt;</description><category>blab</category><category>blag</category><category>learning</category><category>life</category><category>programming</category><guid>https://punchagan.muse-amuse.in/posts/level-up-tools.html</guid><pubDate>Mon, 23 May 2016 16:08:14 GMT</pubDate></item><item><title>Tedium in work-flows</title><link>https://punchagan.muse-amuse.in/posts/tedium-in-work-flows.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
I use &lt;a href="http://getnikola.com"&gt;Nikola&lt;/a&gt; for generating this blog. When creating a new post, it prompts for
a title, and creates a file for the post.
&lt;/p&gt;

&lt;p&gt;
Often I'm starting off with only a vague idea that needs to be fleshed out
before it can be published (or discarded). It is quite difficult to come up
with a title at this stage. I just want to start a draft and write things down!
&lt;/p&gt;

&lt;p&gt;
I could use a "draft-title" and change it after finishing a post, but this
feels tedious – requires 3 steps – change the title, post filename and post
slug.  The last two steps are optional, really, but I feel they are important
especially when the original title is very different from the new one.
&lt;/p&gt;

&lt;p&gt;
Being forced to come up with a title before anything else, feels tedious and,
adds to the effort required to start off a new post.  I shouldn't really be
worrying about the effort required to change the title of an unwritten post,
but it happens subconsciously.
&lt;/p&gt;

&lt;p&gt;
To work around this, I now have a "re-title utility" in my editor that takes
care of all the tedious details.  I can start with a random title, like
Draft-1, and change it when I'm done with the post.  I feel this is going to
lead to a lot more drafts, at the very least, if not published posts.
&lt;/p&gt;

&lt;p&gt;
Another work-flow related thing I came across recently was @Malabarba's &lt;a href="https://github.com/clojure-emacs/cider/issues/1717#issue-150907043"&gt;issue&lt;/a&gt;
on CIDER (an IDE for Clojure in Emacs).  The &lt;a href="http://www.braveclojure.com/getting-started/#Using_the_REPL"&gt;REPL&lt;/a&gt; takes a while to startup and
this caused him to not use CIDER for running tests, if there wasn't an already
open REPL.
&lt;/p&gt;

&lt;p&gt;
The tedium that people feel effects how they use the tool.  Not surprisingly,
making tedious-feeling tasks a breeze with the tool also effects how and how
much they use it.  Subtle variations in a work-flow could make or break it.
How do you discover such potential work-flow make-or-break-ers? I think, these
things would help:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Use the tool yourself (dog-food)
&lt;/li&gt;
&lt;li&gt;Talk to (or watch!) people using your tool
&lt;/li&gt;
&lt;li&gt;Look at work-flows in other similar tools
&lt;/li&gt;
&lt;li&gt;Thinking explicitly about various scenarios and simplifying or improving
work-flows
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
I'd love to hear examples of this, and any ideas or thoughts you may have on
identifying and fixing such things!
&lt;/p&gt;</description><category>blab</category><category>programming</category><category>user-experience</category><category>workflow</category><guid>https://punchagan.muse-amuse.in/posts/tedium-in-work-flows.html</guid><pubDate>Thu, 19 May 2016 11:13:37 GMT</pubDate></item><item><title>Error messages and new users</title><link>https://punchagan.muse-amuse.in/posts/error-messages-and-new-users.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
I was helping a friend of mine setup &lt;a href="http://jajoosam.github.io"&gt;his blog&lt;/a&gt; and we were trying to use &lt;a href="http://hexo.io"&gt;Hexo&lt;/a&gt; –
a static site generator.  We chose a Javascript based tool since he's trying to
learn Javascript.  I skimmed through active Javascript projects in &lt;a href="https://staticsitegenerators.net"&gt;this list&lt;/a&gt;
and finally zeroed down upon Hexo based on its popularity.  I promised to help
my friend to set this up, but he first tried to do it on his own and got back
to me after an hour or so, quite frustrated and almost on the verge of giving
up setting it up.  I didn't expect this from a tool that had so many stars,
forks, plugins and so much active development.
&lt;/p&gt;

&lt;p&gt;
We finally got it working, but we found that the error messages were horrendous
– even for someone who has been using free and open-source tools for a while
now.  Printing out errors from compiler or interpreter directly along with the
stack trace is almost always the worst thing to do for a tool/utility (as
opposed to an API or library).  The stack trace is definitely useful, for
developers trying to build upon or improve your tool.  Have a debug or
development mode where developers can get all the information they need.
&lt;/p&gt;

&lt;p&gt;
If you care about your users, especially new users, make sure you spend
sufficient time on showing human-readable messages. If possible list the
possible causes for every error along with tips for troubleshooting.
&lt;/p&gt;</description><category>blab</category><category>programming</category><category>software</category><category>user-experience</category><guid>https://punchagan.muse-amuse.in/posts/error-messages-and-new-users.html</guid><pubDate>Tue, 17 May 2016 07:22:36 GMT</pubDate></item><item><title>How I learnt to use Emacs' profiler</title><link>https://punchagan.muse-amuse.in/posts/how-i-learnt-to-use-emacs-profiler.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
I learnt to use Emacs' profiler yesterday, after many hours of yak-shaving,
trying to get &lt;a href="https://github.com/novoid/Memacs"&gt;Memacs&lt;/a&gt; working.  Memacs is a &lt;a href="http://en.wikipedia.org/wiki/Memex"&gt;memory extension&lt;/a&gt; system for Emacs
written by Karl Voit, that I have been meaning to try out for a long time now.
Seeing lots of review posts at the turn of the year and watching Karl's recent
&lt;a href="http://emacslife.com/emacs-chats/chat-karl-voit.html"&gt;Emacs Chat with Sacha Chua&lt;/a&gt; pushed me to try and finally set it up.
&lt;/p&gt;

&lt;p&gt;
I started writing a &lt;a href="https://github.com/punchagan/Memacs/blob/chrome/memacs/chromium.py"&gt;module&lt;/a&gt; to create a Memacs file – an org archive file –
from my browser history.  It was pretty easy to write, and I had it spitting
out a huge file with 22k entries after about a couple of hours of work.  Then I
excitedly pulled up my agenda, and turned on the option to view archived
entries, only to be super-disappointed.  It turned out to be extremely slow!
Actually, the agenda never came up with the 22k entries file that I had. At
least not in 5 or so minutes, before I got impatient.  The performance was
unacceptable even when I reduced it to 5k entries.
&lt;/p&gt;

&lt;p&gt;
I was pretty sure it wasn't that slow for Karl in his &lt;a href="https://www.youtube.com/watch?v=SaKPr4J0K2I#t=999"&gt;demo&lt;/a&gt; and &lt;a href="https://twitter.com/punchagan/status/550723377871065088"&gt;tweeted&lt;/a&gt; to him,
asking for a workaround. Meanwhile, I looked at his dot-emacs, but wasn't able
to dig out what was needed to speed up things. He confirmed that his
performance was way better than what I was getting.
&lt;/p&gt;

&lt;p&gt;
First, I ruled out the possibility of it being because of the SSD, since
clearly my CPU usage was peaking, and the task was CPU bound and not I/O.
Next, I tried using the same file on a different machine (with a different
version of Emacs and org-mode), and it worked blazingly fast.  So, it was
either the version of Emacs or org-mode that I was using.
&lt;/p&gt;

&lt;p&gt;
I should have stopped, thought clearly, and started experimenting with org
version, but hindsight is 20-20.  I tried Ubuntu's pre-built Emacs and agendas
were fast!  I suspected my Emacs build, since I recently started building Emacs
from git.  I built two or three other versions of Emacs, and wasted a lot of
time, before realizing that I wasn't using the org-mode source bundled inside
Emacs for the tests, and there were two "independent" variables.
&lt;/p&gt;

&lt;p&gt;
Finally, I began bisecting org-mode's source and found that all hell broke
loose with an &lt;a href="http://orgmode.org/w/?p=org-mode.git;a=commitdiff;h=b88c5464db2cb0d90d4f30e43b5e08d2b1c1fcea;hp=8cc4e09950594b2abec2502e9218318570595ac5"&gt;inconspicuous change&lt;/a&gt; around release 8.2.6.  It turns out that
org-overview was broken before this, and collapsing all the trees in a newly
opened org-buffer (default option) wasn't working. Once this bug was fixed,
opening huge org files would slow down by a great deal, in turn causing agenda
generation to be unbearably slow.
&lt;/p&gt;

&lt;p&gt;
All I had to do was add a &lt;code&gt;#+STARTUP: showeverything&lt;/code&gt; to the top of the file.
This speeded up things by about 50 times!  It turns out, I later found out,
that all of this is documented on &lt;a href="http://orgmode.org/worg/agenda-optimization.html"&gt;Worg&lt;/a&gt;. I did try a few search engine queries,
but sadly none of them brought this up.  Adding the following to my config,
speeded up agenda generation by about 150-200 times!
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;org-agenda-inhibit-startup&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;; ~50x speedup&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;org-agenda-use-tag-inheritance&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;; 3-4x speedup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In the course of all this debugging, I learnt how to use Emacs' profiler.  The
profile reports along with git bisect, eventually helped me figure out what the
problem was.
&lt;/p&gt;

&lt;p&gt;
To profile the CPU usage, all you have to do is add a call like
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;profiler-start&lt;/span&gt; &lt;span class="ss"&gt;'cpu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;;; or M-x profiler-start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
at the place where you wish to start it.  Emacs will then start collecting
information about where time is being spent, by sampling every
&lt;code&gt;sampling-interval&lt;/code&gt; seconds (default 10&lt;sup&gt;6&lt;/sup&gt; nanoseconds = 1 milli second).
&lt;/p&gt;

&lt;p&gt;
You can view the information being collected, at any point of time using
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;profiler-report&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;; or M-x profiler-report&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The report is a nice, interactive tree with the percentage of time spent in
each call. You can stop profiling by calling &lt;code&gt;(profiler-stop)&lt;/code&gt;.  If you have
more than one report, you can compare them by hitting &lt;code&gt;=&lt;/code&gt; in one of the report
buffers.  I'm definitely going to use this for other things! (like speeding up
my startup?)
&lt;/p&gt;

&lt;p&gt;
Now that I have Memacs working with reasonably fast agenda views, I'm looking
forward to collecting as much personal information as I can!  Thanks Karl for
writing Memacs.  I am going to be a pretty heavy user, I think!  There seem to
be a few rough edges, though, and I hope to help smoothen them out a little
bit, over the next few weeks.
&lt;/p&gt;</description><category>emacs</category><category>orgmode</category><category>programming</category><guid>https://punchagan.muse-amuse.in/posts/how-i-learnt-to-use-emacs-profiler.html</guid><pubDate>Fri, 02 Jan 2015 20:31:17 GMT</pubDate></item><item><title>Martin Fowler on Refactoring @ RubyRogues</title><link>https://punchagan.muse-amuse.in/posts/martin-fowler-on-refactoring-rubyrogues.html</link><dc:creator>punchagan</dc:creator><description>&lt;p&gt;
I stumbled on a &lt;a href="http://rubyrogues.com/178-rr-book-club-refactoring-ruby-with-martin-fowler/"&gt;Ruby Rogues podcast&lt;/a&gt; yesterday, which had &lt;a href="http://martinfowlwer.com"&gt;Martin Fowler&lt;/a&gt; as the
guest.  I really enjoyed the discussion on Refactoring (the noun, the verb and
the book!)
&lt;/p&gt;

&lt;p&gt;
Martin clarified in the podcast that refactoring (the verb/process) is a
sequence of very small refactorings, while you keep making sure that you can
run the test suite always.  A refactoring (noun) is a change where you change
the structure of the code without any externally observable changes, with the
intent of making it easier to understand and cheaper to change in future.
&lt;/p&gt;

&lt;p&gt;
I also really liked the metaphor of a 'healthy code base'.  Refactoring is,
then, the process of keeping healthy – exercise, speaking metaphorically.  You
can stack up all the exercise you need to do, until you get really unfit.
Refactoring, similarly, needs to be done regularly, to keep the code base
healthy.  This lets you go faster, in the future.
&lt;/p&gt;

&lt;p&gt;
I also really liked the advise about trying to push back the mental contexts
you build, while trying to debug/understand some code that is not very clear,
by refactoring the code to make it clearer.  Code needn't be one big chunk of
cryptographic text.  Code is writing.  It should be clear and understandable.
Or, at least we should strive to make it so!
&lt;/p&gt;

&lt;p&gt;
The discussion, as always on this podcast, was very lively, pleasant and
enjoyable! Enjoy!
&lt;/p&gt;</description><category>advice</category><category>code</category><category>programming</category><guid>https://punchagan.muse-amuse.in/posts/martin-fowler-on-refactoring-rubyrogues.html</guid><pubDate>Sat, 25 Oct 2014 14:23:25 GMT</pubDate></item><item><title>Recurse Center, 2014-07-07</title><link>https://punchagan.muse-amuse.in/posts/recurse-center-2014-07-07.html</link><dc:creator>punchagan</dc:creator><description>&lt;ul class="org-ul"&gt;
&lt;li&gt;As preparation for a one-on-one this week with one of the facilitators, I was
wondering if I was really getting better as a programmer, by doing what I am
doing.
&lt;/li&gt;
&lt;li&gt;I have heard at numerous places that reading and reflection are keys to
getting better. I feel like I haven't been giving these things much attention
in the past couple of weeks. I don't catch up on reading all the awesome
reading material shared on Zulip and I switched from writing this blog post
first thing in the morning, to any-time-after-lunch. I don't think this
worked out very well. Writing the post worked as a way to reflect on what I
had done yesterday, and what I should be doing today. So, I am back to
writing the blog post, first thing in the morning!
&lt;/li&gt;
&lt;li&gt;Yesterday, I worked on indexing the Python sources in a way that the
inspection code can look up, later.  During this process, I found that my
code to use libclang's AST wasn't generic enough, and I had to clean it up to
be able to extract useful information from any file in the &lt;code&gt;cpython&lt;/code&gt; sources.
&lt;/li&gt;
&lt;li&gt;We also got to attend a super-awesome talk by &lt;a href="http://words.steveklabnik.com/"&gt;Steve Labnik&lt;/a&gt;! He talked about
his progression from being an application developer, to writing libraries, to
working on languages (as a professional developer). He made a lot of
interesting and inspiring points during his talk.  Some of those that stuck
with me are:
&lt;ul class="org-ul"&gt;
&lt;li&gt;None of these is particularly harder than any of the other. Depending on
each person's personality, or the way their brain works, they are good at
doing one or the other.
&lt;/li&gt;
&lt;li&gt;Getting good at programming is a matter of showing up, more than about the
"genes".  He repeated quite a few times that he disliked the idea of "baby
hacker", and left out the story of his childhood and college programming
days! I'm totally stealing his idea of meeting every saturday at 1pm, with
a bunch of friends and working until it was 10pm or so, when they could get
cheap beer and food!  And he did this all through his college!  It is
interesting that this idea is so similar to Hacker School!
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
It was a very enjoyable and inspiring talk on the whole.
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;The plan for today is to actually have the parsed information dumped into
some persistent format, and modify the inspect code to actually use it.
&lt;/li&gt;
&lt;li&gt;I will also be pairing with Kyle for a few hours on working through some of
&lt;a href="http://mitpress.mit.edu/books/audio-programming-book"&gt;http://mitpress.mit.edu/books/audio-programming-book&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><category>programming</category><category>python</category><category>recursecenter</category><category>thought</category><category>writing</category><guid>https://punchagan.muse-amuse.in/posts/recurse-center-2014-07-07.html</guid><pubDate>Tue, 08 Jul 2014 14:07:20 GMT</pubDate></item></channel></rss>